<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Potion Brewing Lab</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #2a1810, #4a2c1a, #6b3e27);
            color: #f4e4bc;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .game-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .title {
            font-size: 2.5em;
            color: #ff6b9d;
            text-shadow: 0 0 20px #ff6b9d;
            margin-bottom: 10px;
        }

        .stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .stat {
            background: rgba(255, 107, 157, 0.1);
            border: 2px solid #ff6b9d;
            border-radius: 10px;
            padding: 15px;
            margin: 5px;
            text-align: center;
            min-width: 150px;
        }

        .stat-value {
            font-size: 1.5em;
            color: #ff6b9d;
            font-weight: bold;
        }

        .brewing-area {
            text-align: center;
            margin-bottom: 40px;
        }

        .cauldron {
            width: 200px;
            height: 200px;
            background: radial-gradient(ellipse at center, #4a4a4a 30%, #2a2a2a 70%, #1a1a1a);
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            margin: 20px auto;
            cursor: pointer;
            transition: all 0.1s ease;
            position: relative;
            border: 4px solid #8b4513;
            box-shadow: 0 0 30px rgba(255, 107, 157, 0.3);
            overflow: hidden;
        }

        .cauldron:hover {
            transform: scale(1.05);
            box-shadow: 0 0 40px rgba(255, 107, 157, 0.5);
        }

        .cauldron:active {
            transform: scale(0.95);
        }

        .cauldron::before {
            content: '';
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            bottom: 40px;
            background: linear-gradient(45deg, #9b59b6, #e74c3c, #f39c12, #2ecc71);
            border-radius: 50%;
            animation: bubble 3s infinite;
            opacity: 0.8;
        }

        @keyframes bubble {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .click-effect {
            position: absolute;
            pointer-events: none;
            font-size: 24px;
            font-weight: bold;
            color: #ff6b9d;
            animation: floatUp 1s ease-out forwards;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0);
            }
            100% {
                opacity: 0;
                transform: translateY(-60px);
            }
        }

        .resource-display {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .resource {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #8b4513;
            border-radius: 8px;
            padding: 10px;
            margin: 5px;
            text-align: center;
            min-width: 100px;
        }

        .resource-name {
            font-size: 0.9em;
            color: #d4c4ac;
        }

        .resource-amount {
            font-size: 1.2em;
            font-weight: bold;
            color: #ff6b9d;
        }

        .upgrades {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .upgrade-category {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid #8b4513;
            border-radius: 10px;
            padding: 20px;
        }

        .upgrade-category h3 {
            color: #ff6b9d;
            margin-bottom: 15px;
            text-align: center;
        }

        .upgrade {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid #8b4513;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .upgrade:hover {
            background: rgba(255, 107, 157, 0.1);
            border-color: #ff6b9d;
        }

        .upgrade.affordable {
            border-color: #2ecc71;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.3);
        }

        .upgrade-name {
            font-weight: bold;
            color: #f4e4bc;
            margin-bottom: 5px;
        }

        .upgrade-description {
            font-size: 0.9em;
            color: #d4c4ac;
            margin-bottom: 8px;
        }

        .upgrade-cost {
            color: #f39c12;
            font-weight: bold;
        }

        .upgrade-owned {
            color: #2ecc71;
            font-size: 0.9em;
        }

        .save-controls {
            text-align: center;
            margin: 20px 0;
            background: rgba(52, 152, 219, 0.1);
            border: 2px solid #3498db;
            border-radius: 15px;
            padding: 20px;
        }

        .save-button {
            margin: 5px;
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .save-button:hover {
            transform: scale(1.05);
        }

        .export-btn { background: #3498db; color: white; }
        .import-btn { background: #2ecc71; color: white; }
        .delete-btn { background: #e74c3c; color: white; }

        .ads-section {
            background: rgba(52, 152, 219, 0.1);
            border: 2px solid #3498db;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin: 30px 0;
        }

        .ad-button {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            border: none;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
            margin: 5px;
        }

        .ad-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.4);
        }

        .ad-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .ascension-section {
            background: rgba(155, 89, 182, 0.1);
            border: 2px solid #9b59b6;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            margin-top: 30px;
        }

        .ascension-button {
            background: linear-gradient(45deg, #9b59b6, #8e44ad);
            border: none;
            color: white;
            padding: 15px 30px;
            font-size: 1.2em;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 15px;
        }

        .ascension-button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(155, 89, 182, 0.5);
        }

        .ascension-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .automation-info {
            background: rgba(46, 204, 113, 0.1);
            border: 1px solid #2ecc71;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            text-align: center;
        }

        .click-frenzy {
            animation: frenzy 0.5s infinite alternate;
        }

        @keyframes frenzy {
            0% { transform: scale(1) rotate(0deg); }
            100% { transform: scale(1.1) rotate(2deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        .automated {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1 class="title">🧪 POTION BREWING LAB 🧪</h1>
            <div class="stats">
                <div class="stat">
                    <div>Gold Coins</div>
                    <div class="stat-value" id="gold">0</div>
                </div>
                <div class="stat">
                    <div>Per Brew</div>
                    <div class="stat-value" id="brewPower">1</div>
                </div>
                <div class="stat">
                    <div>Per Second</div>
                    <div class="stat-value" id="goldPerSecond">0</div>
                </div>
                <div class="stat">
                    <div>Mastery Level</div>
                    <div class="stat-value" id="masteryLevel">1</div>
                </div>
                <div class="stat">
                    <div>Total Brewed</div>
                    <div class="stat-value" id="totalBrewed">0</div>
                </div>
            </div>
        </div>

        <div class="resource-display">
            <div class="resource">
                <div class="resource-name">🌿 Herbs</div>
                <div class="resource-amount" id="herbs">0</div>
            </div>
            <div class="resource">
                <div class="resource-name">💎 Crystals</div>
                <div class="resource-amount" id="crystals">0</div>
            </div>
            <div class="resource">
                <div class="resource-name">⭐ Essence</div>
                <div class="resource-amount" id="essence">0</div>
            </div>
        </div>

        <div class="brewing-area">
            <div class="cauldron" id="cauldron"></div>
            <div class="automation-info" id="automationInfo" style="display: none;">
                🔮 Automated brewing in progress! 🔮
            </div>
        </div>

        <div class="save-controls">
            <h3>💾 SAVE MANAGEMENT 💾</h3>
            <p>Your progress is automatically saved every 30 seconds!</p>
            <div style="margin-top: 15px;">
                <button class="save-button export-btn" onclick="game.exportSave()">
                    Export Save
                </button>
                <button class="save-button import-btn" onclick="importSavePrompt()">
                    Import Save
                </button>
                <button class="save-button delete-btn" onclick="game.deleteSave()">
                    Delete Save
                </button>
            </div>
        </div>

        <div class="upgrades">
            <div class="upgrade-category">
                <h3>🥄 Manual Brewing</h3>
                <div id="manualUpgrades"></div>
            </div>
            <div class="upgrade-category">
                <h3>🤖 Automation</h3>
                <div id="automationUpgrades"></div>
            </div>
            <div class="upgrade-category">
                <h3>🔮 Arcane Arts</h3>
                <div id="arcaneUpgrades"></div>
            </div>
        </div>

        <div class="ads-section">
            <h3>📺 MYSTICAL ADVERTISEMENTS 📺</h3>
            <p>Watch ads to receive magical bonuses!</p>
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 10px; margin-top: 15px;">
                <button class="ad-button" id="goldAdBtn" style="background: linear-gradient(45deg, #f39c12, #e67e22);">
                    <div>💰 Gold Boost</div>
                    <div style="font-size: 0.8em;">+1 hour of production</div>
                    <div style="font-size: 0.8em;" id="goldAdCooldown">Ready!</div>
                </button>
                <button class="ad-button" id="resourceAdBtn" style="background: linear-gradient(45deg, #27ae60, #2ecc71);">
                    <div>🌿 Resource Pack</div>
                    <div style="font-size: 0.8em;">Herbs, Crystals & Essence</div>
                    <div style="font-size: 0.8em;" id="resourceAdCooldown">Ready!</div>
                </button>
                <button class="ad-button" id="clickAdBtn" style="background: linear-gradient(45deg, #e74c3c, #c0392b);">
                    <div>⚡ Click Frenzy</div>
                    <div style="font-size: 0.8em;">3x click power for 20s</div>
                    <div style="font-size: 0.8em;" id="clickAdCooldown">Ready!</div>
                </button>
            </div>
        </div>

        <div class="ascension-section">
            <h3>✨ MYSTICAL ASCENSION ✨</h3>
            <p>Transcend to a higher plane of alchemy!</p>
            <p id="ascensionInfo">Ascend for +<span id="ascensionBonus">0</span>% brewing efficiency</p>
            <button class="ascension-button" id="ascensionBtn" disabled>
                Ascend (Need 10,000,000 total gold)
            </button>
        </div>
    </div>

    <script>
        // Custom encryption class
        class GameCrypto {
            constructor() {
                this.scramblePattern = [3, 1, 4, 1, 5, 9, 2, 6];
            }

            xorEncrypt(text, key) {
                let result = '';
                for (let i = 0; i < text.length; i++) {
                    const charCode = text.charCodeAt(i);
                    const keyChar = key.charCodeAt(i % key.length);
                    result += String.fromCharCode(charCode ^ keyChar);
                }
                return result;
            }

            customBase64Encode(str) {
                const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                const customAlphabet = 'ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba9876543210-_';
                
                let result = btoa(str);
                let encoded = '';
                
                for (let i = 0; i < result.length; i++) {
                    const index = alphabet.indexOf(result[i]);
                    encoded += index !== -1 ? customAlphabet[index] : result[i];
                }
                return encoded;
            }

            customBase64Decode(str) {
                const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                const customAlphabet = 'ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba9876543210-_';
                
                let decoded = '';
                for (let i = 0; i < str.length; i++) {
                    const index = customAlphabet.indexOf(str[i]);
                    decoded += index !== -1 ? alphabet[index] : str[i];
                }
                return atob(decoded);
            }

            encrypt(data) {
                try {
                    let jsonString = JSON.stringify(data);
                    const checksum = this.generateChecksum(jsonString);
                    jsonString = checksum + '|' + jsonString;
                    
                    const secretKey = 'PotionMaster2024!';
                    let encrypted = this.xorEncrypt(jsonString, secretKey);
                    encrypted = this.customBase64Encode(encrypted);
                    
                    return 'v1.' + encrypted;
                } catch (error) {
                    console.error('Encryption failed:', error);
                    return null;
                }
            }

            decrypt(encryptedData) {
                try {
                    if (!encryptedData.startsWith('v1.')) {
                        throw new Error('Invalid save version');
                    }
                    let encrypted = encryptedData.substring(3);
                    
                    encrypted = this.customBase64Decode(encrypted);
                    
                    const secretKey = 'PotionMaster2024!';
                    let decrypted = this.xorEncrypt(encrypted, secretKey);
                    
                    const parts = decrypted.split('|');
                    if (parts.length !== 2) {
                        throw new Error('Invalid save format');
                    }
                    
                    const [checksum, jsonString] = parts;
                    const calculatedChecksum = this.generateChecksum(jsonString);
                    
                    if (checksum !== calculatedChecksum) {
                        throw new Error('Save data corrupted');
                    }
                    
                    return JSON.parse(jsonString);
                } catch (error) {
                    console.error('Decryption failed:', error);
                    return null;
                }
            }

            generateChecksum(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash).toString(36);
            }
        }

        // Main game class
        class PotionBrewingGame {
            constructor() {
                // Game state
                this.gold = 0;
                this.herbs = 0;
                this.crystals = 0;
                this.essence = 0;
                this.totalBrewed = 0;
                this.brewPower = 1;
                this.goldPerSecond = 0;
                this.masteryLevel = 1;
                this.masteryBonus = 0;

                // Save system
                this.crypto = new GameCrypto();
                this.saveKey = 'potionBrewingSave';
                this.autoSaveInterval = 30000;

                // Ad system
                this.adCooldowns = {
                    gold: 0,
                    resource: 0,
                    click: 0
                };
                this.clickFrenzyActive = false;
                this.clickFrenzyEnd = 0;

                // Upgrade definitions
                this.upgrades = {
                    manual: [
                        { name: "Silver Spoon", cost: { gold: 25 }, owned: 0, effect: 1, description: "Brewing power +1 per click" },
                        { name: "Crystal Stirrer", cost: { gold: 150 }, owned: 0, effect: 2, description: "Brewing power +2 per click" },
                        { name: "Mithril Ladle", cost: { gold: 1500, herbs: 100 }, owned: 0, effect: 8, description: "Brewing power +8 per click" },
                        { name: "Phoenix Feather Wand", cost: { gold: 25000, crystals: 200 }, owned: 0, effect: 35, description: "Brewing power +35 per click" },
                        { name: "Dragon Scale Catalyst", cost: { gold: 500000, essence: 50 }, owned: 0, effect: 150, description: "Brewing power +150 per click" }
                    ],
                    automation: [
                        { name: "Apprentice Helper", cost: { gold: 100 }, owned: 0, effect: 1, description: "Generates 1 gold/sec" },
                        { name: "Brewing Familiar", cost: { gold: 800, herbs: 50 }, owned: 0, effect: 2, description: "Generates 2 gold/sec" },
                        { name: "Enchanted Cauldron", cost: { gold: 8000, crystals: 75 }, owned: 0, effect: 10, description: "Generates 10 gold/sec" },
                        { name: "Alchemical Golem", cost: { gold: 100000, essence: 25 }, owned: 0, effect: 50, description: "Generates 50 gold/sec" },
                        { name: "Arcane Laboratory", cost: { gold: 1500000, essence: 200 }, owned: 0, effect: 250, description: "Generates 250 gold/sec" },
                        { name: "Dimensional Brewery", cost: { gold: 25000000, essence: 1000 }, owned: 0, effect: 1200, description: "Generates 1200 gold/sec" }
                    ],
                    arcane: [
                        { name: "Herb Transmutation", cost: { gold: 500, herbs: 25 }, owned: 0, effect: 0.05, description: "+5% to all production" },
                        { name: "Crystal Amplification", cost: { gold: 5000, crystals: 50 }, owned: 0, effect: 0.1, description: "+10% to all production" },
                        { name: "Essence Manipulation", cost: { gold: 50000, essence: 15 }, owned: 0, effect: 0.15, description: "+15% to all production" },
                        { name: "Reality Distortion", cost: { gold: 750000, essence: 100 }, owned: 0, effect: 0.25, description: "+25% to all production" },
                        { name: "Cosmic Convergence", cost: { gold: 10000000, essence: 500 }, owned: 0, effect: 0.5, description: "+50% to all production" }
                    ]
                };

                this.init();
            }

            init() {
                // Event listeners
                document.getElementById('cauldron').addEventListener('click', (e) => this.brewPotion(e));
                document.getElementById('ascensionBtn').addEventListener('click', () => this.ascend());
                
                document.getElementById('goldAdBtn').addEventListener('click', () => this.watchAd('gold'));
                document.getElementById('resourceAdBtn').addEventListener('click', () => this.watchAd('resource'));
                document.getElementById('clickAdBtn').addEventListener('click', () => this.watchAd('click'));
                
                // Initialize game
                this.loadGame();
                this.calculateStats();
                this.updateDisplay();
                this.renderUpgrades();
                this.gameLoop();

                // Auto-save setup
                setInterval(() => this.saveGame(), this.autoSaveInterval);
                window.addEventListener('beforeunload', () => this.saveGame());
            }

            brewPotion(e) {
                let effectiveBrewPower = Math.floor(this.brewPower * (1 + this.masteryBonus / 100));
                
                // Apply click frenzy
                if (this.clickFrenzyActive && Date.now() < this.clickFrenzyEnd) {
                    effectiveBrewPower *= 3;
                    document.getElementById('cauldron').classList.add('click-frenzy');
                } else if (this.clickFrenzyActive) {
                    this.clickFrenzyActive = false;
                    document.getElementById('cauldron').classList.remove('click-frenzy');
                }
                
                this.gold += effectiveBrewPower;
                this.totalBrewed += effectiveBrewPower;

                // Generate secondary resources
                if (Math.random() < 0.05) this.herbs += Math.floor(effectiveBrewPower / 10) || 1;
                if (Math.random() < 0.02) this.crystals += Math.floor(effectiveBrewPower / 25) || 1;
                if (Math.random() < 0.008) this.essence += Math.floor(effectiveBrewPower / 50) || 1;

                this.showClickEffect(e, effectiveBrewPower);
                this.updateDisplay();
                this.updateUpgradeAffordability();
            }

            showClickEffect(e, amount) {
                const effect = document.createElement('div');
                effect.className = 'click-effect';
                effect.textContent = `+${this.formatNumber(amount)}`;
                effect.style.left = e.clientX + 'px';
                effect.style.top = e.clientY + 'px';
                effect.style.position = 'fixed';
                document.body.appendChild(effect);

                setTimeout(() => effect.remove(), 1000);
            }

            buyUpgrade(category, index) {
                const upgrade = this.upgrades[category][index];
                const cost = this.getUpgradeCost(upgrade);

                if (this.canAfford(cost)) {
                    this.payResources(cost);
                    upgrade.owned++;
                    this.calculateStats();
                    this.updateDisplay();
                    this.renderUpgrades();
                }
            }

            canAfford(cost) {
                if (cost.gold && this.gold < cost.gold) return false;
                if (cost.herbs && this.herbs < cost.herbs) return false;
                if (cost.crystals && this.crystals < cost.crystals) return false;
                if (cost.essence && this.essence < cost.essence) return false;
                return true;
            }

            payResources(cost) {
                if (cost.gold) this.gold -= cost.gold;
                if (cost.herbs) this.herbs -= cost.herbs;
                if (cost.crystals) this.crystals -= cost.crystals;
                if (cost.essence) this.essence -= cost.essence;
            }

            getUpgradeCost(upgrade) {
                const multiplier = Math.pow(1.25, upgrade.owned);
                const cost = {};
                if (upgrade.cost.gold) cost.gold = Math.floor(upgrade.cost.gold * multiplier);
                if (upgrade.cost.herbs) cost.herbs = Math.floor(upgrade.cost.herbs * multiplier);
                if (upgrade.cost.crystals) cost.crystals = Math.floor(upgrade.cost.crystals * multiplier);
                if (upgrade.cost.essence) cost.essence = Math.floor(upgrade.cost.essence * multiplier);
                return cost;
            }

            calculateStats() {
                // Calculate manual brewing power
                this.brewPower = 1;
                this.upgrades.manual.forEach(upgrade => {
                    this.brewPower += upgrade.owned * upgrade.effect;
                });

                // Calculate automation
                this.goldPerSecond = 0;
                this.upgrades.automation.forEach(upgrade => {
                    this.goldPerSecond += upgrade.owned * upgrade.effect;
                });

                // Apply arcane bonuses
                let multiplier = 1;
                this.upgrades.arcane.forEach(upgrade => {
                    multiplier += upgrade.owned * upgrade.effect;
                });

                this.brewPower = Math.floor(this.brewPower * multiplier);
                this.goldPerSecond = Math.floor(this.goldPerSecond * multiplier);

                // Apply mastery bonus
                this.brewPower = Math.floor(this.brewPower * (1 + this.masteryBonus / 100));
                this.goldPerSecond = Math.floor(this.goldPerSecond * (1 + this.masteryBonus / 100));

                // Show automation info
                const automationInfo = document.getElementById('automationInfo');
                if (this.goldPerSecond > 0) {
                    automationInfo.style.display = 'block';
                    document.getElementById('cauldron').classList.add('automated');
                } else {
                    automationInfo.style.display = 'none';
                    document.getElementById('cauldron').classList.remove('automated');
                }
            }

            updateDisplay() {
                document.getElementById('gold').textContent = this.formatNumber(this.gold);
                document.getElementById('herbs').textContent = this.formatNumber(this.herbs);
                document.getElementById('crystals').textContent = this.formatNumber(this.crystals);
                document.getElementById('essence').textContent = this.formatNumber(this.essence);
                document.getElementById('brewPower').textContent = this.formatNumber(this.brewPower);
                document.getElementById('goldPerSecond').textContent = this.formatNumber(this.goldPerSecond);
                document.getElementById('masteryLevel').textContent = this.masteryLevel;
                document.getElementById('totalBrewed').textContent = this.formatNumber(this.totalBrewed);

                // Update ascension info
                const ascensionBonus = this.masteryLevel * 25;
                document.getElementById('ascensionBonus').textContent = ascensionBonus;
                
                const ascensionBtn = document.getElementById('ascensionBtn');
                if (this.totalBrewed >= 10000000) {
                    ascensionBtn.disabled = false;
                    ascensionBtn.textContent = `Ascend to Mastery ${this.masteryLevel + 1} (+${ascensionBonus}% bonus!)`;
                } else {
                    ascensionBtn.disabled = true;
                    const needed = this.formatNumber(10000000 - this.totalBrewed);
                    ascensionBtn.textContent = `Need ${needed} more gold to ascend`;
                }
            }

            renderUpgrades() {
                this.renderUpgradeCategory('manual', 'manualUpgrades');
                this.renderUpgradeCategory('automation', 'automationUpgrades');
                this.renderUpgradeCategory('arcane', 'arcaneUpgrades');
            }

            renderUpgradeCategory(category, containerId) {
                const container = document.getElementById(containerId);
                container.innerHTML = '';

                this.upgrades[category].forEach((upgrade, index) => {
                    const cost = this.getUpgradeCost(upgrade);
                    const canAfford = this.canAfford(cost);

                    const upgradeEl = document.createElement('div');
                    upgradeEl.className = `upgrade ${canAfford ? 'affordable' : ''}`;
                    upgradeEl.onclick = () => this.buyUpgrade(category, index);

                    const costText = Object.entries(cost).map(([resource, amount]) => {
                        return `${this.formatNumber(amount)} ${resource}`;
                    }).join(', ');

                    upgradeEl.innerHTML = `
                        <div class="upgrade-name">${upgrade.name}</div>
                        <div class="upgrade-description">${upgrade.description}</div>
                        <div class="upgrade-cost">Cost: ${costText}</div>
                        <div class="upgrade-owned">Owned: ${upgrade.owned}</div>
                    `;

                    container.appendChild(upgradeEl);
                });
            }

            updateUpgradeAffordability() {
                ['manual', 'automation', 'arcane'].forEach(category => {
                    const containerId = category + 'Upgrades';
                    const container = document.getElementById(containerId);
                    const upgradeElements = container.querySelectorAll('.upgrade');
                    
                    this.upgrades[category].forEach((upgrade, index) => {
                        const cost = this.getUpgradeCost(upgrade);
                        const canAfford = this.canAfford(cost);
                        const upgradeEl = upgradeElements[index];
                        
                        if (upgradeEl) {
                            if (canAfford) {
                                upgradeEl.classList.add('affordable');
                            } else {
                                upgradeEl.classList.remove('affordable');
                            }
                        }
                    });
                });
            }

            watchAd(adType) {
                const currentTime = Date.now();
                
                if (this.adCooldowns[adType] > currentTime) {
                    return;
                }
                
                const button = document.getElementById(adType + 'AdBtn');
                button.disabled = true;
                button.style.opacity = '0.5';
                
                const cooldownEl = document.getElementById(adType + 'AdCooldown');
                cooldownEl.textContent = 'Watching...';
                
                setTimeout(() => {
                    this.grantAdReward(adType);
                    
                    const cooldownTimes = { gold: 10 * 60 * 1000, resource: 20 * 60 * 1000, click: 30 * 60 * 1000 };
                    this.adCooldowns[adType] = currentTime + cooldownTimes[adType];
                    
                    button.disabled = false;
                    button.style.opacity = '1';
                    this.updateDisplay();
                }, 2000);
            }

            grantAdReward(adType) {
                switch(adType) {
                    case 'gold':
                        const goldBonus = this.goldPerSecond * 1 * 60 * 60;
                        this.gold += goldBonus;
                        this.totalBrewed += goldBonus;
                        this.showAdReward(`+${this.formatNumber(goldBonus)} Gold!`);
                        break;
                        
                    case 'resource':
                        const herbBonus = Math.max(20, this.goldPerSecond * 3);
                        const crystalBonus = Math.max(8, this.goldPerSecond * 1.5);
                        const essenceBonus = Math.max(3, this.goldPerSecond * 0.5);
                        
                        this.herbs += herbBonus;
                        this.crystals += crystalBonus;
                        this.essence += essenceBonus;
                        
                        this.showAdReward(`Resources Pack Received!`);
                        break;
                        
                    case 'click':
                        this.clickFrenzyActive = true;
                        this.clickFrenzyEnd = Date.now() + 20000;
                        document.getElementById('cauldron').classList.add('click-frenzy');
                        this.showAdReward(`Click Frenzy Activated!`);
                        break;
                }
            }

            showAdReward(message) {
                const reward = document.createElement('div');
                reward.style.position = 'fixed';
                reward.style.top = '50%';
                reward.style.left = '50%';
                reward.style.transform = 'translate(-50%, -50%)';
                reward.style.background = 'linear-gradient(45deg, #3498db, #2980b9)';
                reward.style.color = 'white';
                reward.style.padding = '20px 30px';
                reward.style.borderRadius = '15px';
                reward.style.fontSize = '1.5em';
                reward.style.fontWeight = 'bold';
                reward.style.zIndex = '1000';
                reward.style.boxShadow = '0 0 30px rgba(52, 152, 219, 0.6)';
                reward.textContent = message;
                
                document.body.appendChild(reward);
                setTimeout(() => reward.remove(), 3000);
            }

            ascend() {
                if (this.totalBrewed >= 10000000) {
                    this.masteryLevel++;
                    this.masteryBonus = (this.masteryLevel - 1) * 25;
                    
                    this.gold = 0;
                    this.herbs = 0;
                    this.crystals = 0;
                    this.essence = 0;
                    this.totalBrewed = 0;
                    
                    Object.values(this.upgrades).forEach(category => {
                        category.forEach(upgrade => upgrade.owned = 0);
                    });

                    this.calculateStats();
                    this.updateDisplay();
                    this.renderUpgrades();
                }
            }

            gameLoop() {
                const currentTime = Date.now();
                
                if (this.goldPerSecond > 0) {
                    this.gold += this.goldPerSecond / 10;
                    this.totalBrewed += this.goldPerSecond / 10;
                    
                    if (Math.random() < 0.01) this.herbs += Math.floor(this.goldPerSecond / 50) || 1;
                    if (Math.random() < 0.005) this.crystals += Math.floor(this.goldPerSecond / 100) || 1;
                    if (Math.random() < 0.002) this.essence += Math.floor(this.goldPerSecond / 200) || 1;
                    
                    this.updateDisplay();
                    this.updateUpgradeAffordability();
                }
                
                this.updateAdCooldowns(currentTime);
                
                if (this.clickFrenzyActive && currentTime >= this.clickFrenzyEnd) {
                    this.clickFrenzyActive = false;
                    document.getElementById('cauldron').classList.remove('click-frenzy');
                }
                
                setTimeout(() => this.gameLoop(), 100);
            }

            updateAdCooldowns(currentTime) {
                Object.keys(this.adCooldowns).forEach(adType => {
                    const button = document.getElementById(adType + 'AdBtn');
                    const cooldownEl = document.getElementById(adType + 'AdCooldown');
                    
                    if (this.adCooldowns[adType] > currentTime) {
                        const remaining = Math.ceil((this.adCooldowns[adType] - currentTime) / 1000);
                        const minutes = Math.floor(remaining / 60);
                        const seconds = remaining % 60;
                        cooldownEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                        button.disabled = true;
                    } else {
                        cooldownEl.textContent = 'Ready!';
                        button.disabled = false;
                    }
                });
            }

            saveGame() {
                try {
                    const saveData = {
                        gold: this.gold,
                        herbs: this.herbs,
                        crystals: this.crystals,
                        essence: this.essence,
                        totalBrewed: this.totalBrewed,
                        masteryLevel: this.masteryLevel,
                        masteryBonus: this.masteryBonus,
                        upgrades: this.upgrades,
                        timestamp: Date.now(),
                        version: '1.0'
                    };

                    const encrypted = this.crypto.encrypt(saveData);
                    if (encrypted) {
                        localStorage.setItem(this.saveKey, encrypted);
                        this.showSaveNotification('Game Saved!');
                    }
                } catch (error) {
                    console.error('Save failed:', error);
                    this.showSaveNotification('Save Failed!', true);
                }
            }

            loadGame() {
                try {
                    const encryptedSave = localStorage.getItem(this.saveKey);
                    if (!encryptedSave) {
                        return;
                    }

                    const saveData = this.crypto.decrypt(encryptedSave);
                    if (!saveData) {
                        return;
                    }

                    this.gold = saveData.gold || 0;
                    this.herbs = saveData.herbs || 0;
                    this.crystals = saveData.crystals || 0;
                    this.essence = saveData.essence || 0;
                    this.totalBrewed = saveData.totalBrewed || 0;
                    this.masteryLevel = saveData.masteryLevel || 1;
                    this.masteryBonus = saveData.masteryBonus || 0;

                    if (saveData.upgrades) {
                        Object.keys(saveData.upgrades).forEach(category => {
                            if (this.upgrades[category]) {
                                saveData.upgrades[category].forEach((upgrade, index) => {
                                    if (this.upgrades[category][index]) {
                                        this.upgrades[category][index].owned = upgrade.owned || 0;
                                    }
                                });
                            }
                        });
                    }

                    this.showSaveNotification('Game Loaded!');
                } catch (error) {
                    console.error('Load failed:', error);
                }
            }

            exportSave() {
                const saveData = {
                    gold: this.gold,
                    herbs: this.herbs,
                    crystals: this.crystals,
                    essence: this.essence,
                    totalBrewed: this.totalBrewed,
                    masteryLevel: this.masteryLevel,
                    masteryBonus: this.masteryBonus,
                    upgrades: this.upgrades,
                    timestamp: Date.now(),
                    version: '1.0'
                };

                const encrypted = this.crypto.encrypt(saveData);
                
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(encrypted).then(() => {
                        this.showSaveNotification('Save copied to clipboard!');
                    });
                } else {
                    const textArea = document.createElement('textarea');
                    textArea.value = encrypted;
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    this.showSaveNotification('Save copied to clipboard!');
                }

                return encrypted;
            }

            importSave(saveString) {
                try {
                    const saveData = this.crypto.decrypt(saveString.trim());
                    if (!saveData) {
                        this.showSaveNotification('Invalid save data!', true);
                        return false;
                    }

                    if (confirm('This will overwrite your current progress. Continue?')) {
                        this.gold = saveData.gold || 0;
                        this.herbs = saveData.herbs || 0;
                        this.crystals = saveData.crystals || 0;
                        this.essence = saveData.essence || 0;
                        this.totalBrewed = saveData.totalBrewed || 0;
                        this.masteryLevel = saveData.masteryLevel || 1;
                        this.masteryBonus = saveData.masteryBonus || 0;

                        Object.values(this.upgrades).forEach(category => {
                            category.forEach(upgrade => upgrade.owned = 0);
                        });

                        if (saveData.upgrades) {
                            Object.keys(saveData.upgrades).forEach(category => {
                                if (this.upgrades[category]) {
                                    saveData.upgrades[category].forEach((upgrade, index) => {
                                        if (this.upgrades[category][index]) {
                                            this.upgrades[category][index].owned = upgrade.owned || 0;
                                        }
                                    });
                                }
                            });
                        }

                        this.calculateStats();
                        this.updateDisplay();
                        this.renderUpgrades();
                        this.saveGame();

                        this.showSaveNotification('Save imported successfully!');
                        return true;
                    }
                } catch (error) {
                    console.error('Import failed:', error);
                    this.showSaveNotification('Import failed!', true);
                }
                return false;
            }

            deleteSave() {
                if (confirm('Are you sure you want to delete your save? This cannot be undone!')) {
                    localStorage.removeItem(this.saveKey);
                    location.reload();
                }
            }

            showSaveNotification(message, isError = false) {
                const notification = document.createElement('div');
                notification.style.position = 'fixed';
                notification.style.top = '20px';
                notification.style.right = '20px';
                notification.style.background = isError ? '#e74c3c' : '#27ae60';
                notification.style.color = 'white';
                notification.style.padding = '10px 20px';
                notification.style.borderRadius = '5px';
                notification.style.zIndex = '1001';
                notification.style.fontSize = '14px';
                notification.style.boxShadow = '0 2px 10px rgba(0,0,0,0.3)';
                notification.textContent = message;
                
                document.body.appendChild(notification);
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 3000);
            }

            formatNumber(num) {
                if (num < 1000) return Math.floor(num).toString();
                if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
                if (num < 1000000000) return (num / 1000000).toFixed(1) + 'M';
                if (num < 1000000000000) return (num / 1000000000).toFixed(1) + 'B';
                return (num / 1000000000000).toFixed(1) + 'T';
            }
        }

        // Global functions for buttons
        function importSavePrompt() {
            const saveString = prompt('Paste your save string here:');
            if (saveString) {
                game.importSave(saveString);
            }
        }

        // Start the game
        const game = new PotionBrewingGame();
    </script>
</body>
</html>